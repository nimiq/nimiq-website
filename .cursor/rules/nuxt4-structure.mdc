---
alwaysApply: true
---

# Nuxt 4 Project Structure & Environment Rules

## Project Architecture

This project uses **Nuxt 4** with the new directory structure and auto-imports. The codebase is designed to work across two main environments:

### 1. NuxtHub Environment
- **Purpose**: Server-side rendering and dynamic functionality
- **Builds**: `nuxthub-preview`, `nuxthub-production`, `local`
- **Features**: Full SSR, API routes, dynamic content
- **Modules**: Includes `@nuxthub/core`, analytics, SEO features

### 2. Static Production Build
- **Purpose**: Static site generation for end users
- **Builds**: `production`, `github-pages`, `internal-static`
- **Features**: Build-time rendering only, no server runtime
- **Modules**: Excludes NuxtHub, includes static optimization

## Directory Structure

```
app/
├── components/          # Auto-imported Vue components
│   ├── [UI]/          # UI component library (no prefix)
│   ├── [Backgrounds]/ # Background components (no prefix)
│   └── ...            # Regular components
├── composables/        # Auto-imported composables
├── pages/             # File-based routing
├── layouts/           # Page layouts
├── middleware/        # Route middleware
├── plugins/           # Nuxt plugins
├── utils/             # Utility functions
├── types/             # TypeScript type definitions
├── slices/            # Prismic slice components
└── assets/            # Static assets

server/                 # Server-side API routes (NuxtHub only)
lib/                    # Shared utilities and configuration
modules/                # Custom Nuxt modules
```

## Environment Configuration

### Environment Variables
- `NUXT_ENVIRONMENT`: Controls build type and features
- `NUXT_SITE_ENV`: Controls site environment (`preview`/`production`)
- `PRISMIC_ACCESS_TOKEN`: Required for content fetching

### Environment Detection
```typescript
// Use the environment utility from lib/env.ts
import environment from '~/lib/env'

// Check if running on NuxtHub
if (environment.useNuxtHub) {
  // Server-side features available
}

// Check specific environment
if (environment.environment.isProduction) {
  // Production-only logic
}
```

## Key Rules

### 1. Environment-Aware Code
- **Always** check environment before using server-only features
- **Never** assume SSR capabilities in static builds
- **Use** `environment.useNuxtHub` to gate server functionality

### 2. Auto-Imports
- **Components**: Automatically imported from `~/components/`
- **Composables**: Automatically imported from `~/composables/`
- **Utils**: Automatically imported from `~/utils/`
- **No** manual imports needed for these directories

### 3. Build-Time vs Runtime
- **Static builds**: Use `useAsyncData` for build-time data
- **NuxtHub builds**: Use `useQuery` for runtime data
- **Conditional modules**: Check environment before enabling features

### 4. Prismic Integration
- **Content**: Fetched at build time for static builds
- **Preview**: Available in NuxtHub environments
- **Slices**: Use `~/slices/` directory for Prismic components

### 5. Performance Considerations
- **Static builds**: Optimize for build-time performance
- **NuxtHub builds**: Consider runtime performance
- **Analytics**: Loaded in all environments but behavior controlled by composables

## Common Patterns

### Environment-Checking
```typescript
// ✅ Good: Check environment before server features
export function useServerFeature() {
  if (!environment.useNuxtHub) {
    return { data: null, error: 'Not available in static builds' }
  }
  // Server-only logic
}

// ❌ Bad: Assume server features exist
export function useServerFeature() {
  // This will fail in static builds
  return useQuery({ query: () => fetchFromServer() })
}
```

### Conditional Module Usage
```typescript
// ✅ Good: Environment-aware module loading
if (!environment.useNuxtHub) {
  // Only load static optimization modules
  modules.push('nuxt-og-image')
}
```

### Data Fetching Strategy
```typescript
// ✅ Good: Environment-appropriate data fetching
export function useContent() {
  if (environment.useNuxtHub) {
    return useQuery({ key: 'content', query: fetchContent })
  } else {
    return useAsyncData('content', fetchContent)
  }
}
```
